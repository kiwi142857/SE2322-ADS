# HNSW

> 522031910299 + 陈启炜

## 环境说明

本测试在VMware Workstation Pro 17 中Ubuntu22.04虚拟机环境下运行。
主机硬件为CPU：Intel i5 12500H, Memory: 16GB

## 实验过程中的难点/印象较深的点
    本实验助教提供了伪代码，文档内容较清晰，同时提供了测试、记录时间等相关代码，编程均集中在HNSW的实现上，总体效果较好，收获大。  
    印象较深的点有：
1. neighbor的初始化：在最开始实现时，neighbor未初始化导致出现seg fault错误。
2. SEARCH_LAYER函数的最近邻元素集合添加方式：自己在实现时未仔细阅读伪代码，在访问邻居节点前将当前查询元素也加入到最近元素集合中，导致元素重复。（最近元素的集合采用优先级队列实现）  
3. 在测试过程中，注意到M=20， M_max=30的情况下，召回率达到0.999，并且query time = 0.3 ms，效果较好。但可能与测试集有关。
    收获：  
1. 之前写代码时，常常没有整体结构梳理成伪代码/文档，就开始写，导致常常需要重构，在本次实验中，感受到在大致完成伪代码后实现的优势。
2. 参数与类的声明/实现分离，设计parameter.hpp，方便修改。（但是修改后直接``make grade``没有将其他部分重新编译，需``make clean``后再``make grade``）


## 5.2 召回率与单次查询时延的关系

 M=M_max                | 10    | 20    | 30    | 40    | 50    |
|:-----------------------|:------|:------|:------|:------|:------|
| recall_rate            | 0.712 | 0.976 | 0.937 | 0.987 | 0.990 |
| query_time_per_element | 0.2ms | 0.4ms | 0.4ms | 0.6ms | 0.7ms |

在M=M_max=10,20,30,40,50的情况下，随着M的增加，召回率总体升高，但是在M=30时较低。
分析原因：
1. 随着M增大，召回率升高的原因： M的值增大，使每个点的邻居数量更多，图更稠密，更多的节点会被保留为候选节点，因此在搜索时会更有可能找到更接近目标的节点，有更多的路径到达目标，理论上搜索的结果更加准确。
2. M=30时，召回率降低的原因：可能与数据集的数据有关，当M恰好等于30时，搜索过程中，相比于M=20会访问较多节点，可能由于某些节点与目标节点更接近而选择该节点，但该节点最终导向错误路径，从而降低召回率；相比与M=40时，访问节点数较少，M=40时，可能存在某些路径最终导向正确目标节点而M=30并没有相应数据，从而降低召回率。

## 5.3 性能测试

| M=M_max                 | 10          | 20          | 30          | 40          | 50          |
|:------------------------|:------------|:------------|:------------|:------------|:------------|
| recall_rate             | 0.712       | 0.976       | 0.937       | 0.987       | 0.990       |
| insert_time_per_element | 19353.2 ns  | 41575.6 ns  | 70889.9 ns  | 108594.6 ns | 140301.3 ns |
| query_time_per_element  | 186450.0 ns | 337480.0 ns | 505550.0 ns | 566810.0 ns | 752920.0 ns |
| multi_thread_query      | 160280.0 ns | 316860.0 ns | 454230.0 ns | 514100.0 ns | 546140.0 ns |

总体上看，多线程的查询效率高于单线程，并且随着M的增大，多线程的优化效果越明显。  
分析原因：由于本测试中，不对查询过程中，增加数据，删除数据的考虑，因此对hnsw结构未加锁，优化效果明显。  
随着M的增加，单次查询需要访问的数据增多，多线程的优势更加明显。